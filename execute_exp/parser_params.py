import argparse
import sys

def help_msg() -> str:
    return tool_options_msg() + exec_mode_msg() + strategy_msg() + revalidation_msg() + hashes_msg() + storage_msg() + num_dicts_msg() + retrieval_strategies_msg() + retrieval_exec_modes_msg()

def tool_options_msg():
    return "\nSpeeduPy's command line arguments help:\n\n\
    To run your experiment with SpeeduPy use:\n\
    $ python "+str(sys.argv[0])+" program_arguments [-h, --help] [OPTIONS]\n\n\
    To run in the SpeeduPy DEBUG mode use:\n\
    $ DEBUG=True python "+str(sys.argv[0])+" program_arguments [-h, --help] [OPTIONS]\n\n"

def exec_mode_msg():
    return "\nExecution Mode - Defines how SpeeduPy will execute:\n\
    =>no-cache      : SpeeduPy will cache no functions\n\
    =>manual        : SpeeduPy only caches the functions annotated by the user with @deterministic\n\" \
    =>accurate      : SpeeduPy looks for statistically pure functions and only caches function calls that always returned the same output\n\
    =>multiprocess  : SpeeduPy mixes 'manual' and 'no-cache' modes, executing both and return the one that first end\n\
    =>probabilistic : SpeeduPy looks for statistically pure functions and caches function calls that sometimes returned different outputs, according to the policy set on --strategy param\n"

def strategy_msg():
    return "\nStrategy - Defines SpeeduPy\'s policy for caching function calls when executing in probabilistic mode\n\
    =>error    : SpeeduPy only caches function calls that introduce errors up to a user-specified limit\n\
    =>counting : SpeeduPy only caches function calls whose most produced output occurred at least a minimum percentage of times defined by the user. The output that appeared most times will always be returned.\n"

def revalidation_msg():
    return "\nRevalidation options:\n\
    =>none       : SpeeduPy will never reexecute a function it classified as statistically pure\n\
    =>fixed      : SpeeduPy will reexecute a function it classified as statistically pure always after a fixed number of cached function calls\n\
    =>adaptative : SpeeduPy will reexecute a function it classified as statistically pure. The number of cached function calls before the revalidation occurs varies according to the historical behaviour of the function.\n"

def hashes_msg():
    return "\nHashes: \n\
    =>md5   : is a cryptographic hash fuction with a better collision resistence and lower performance compared to the others.\n\
    =>murmur: is a modern non-cryptographic hash function with a low collision rate and high performance.\n\
    =>xxhash: is a modern non-cryptographic hash function with a lower collision resistence and better performance compered to murmur.\n"

def storage_msg():
    return "\nStorage:\n\
    =>db     : use a database to store data\n\
    =>file   : use the filesystem to store data.\n"

def num_dicts_msg():
    return "\nNumber of dictionaries options:\n\
    =>0      : SpeeduPy will always request and save data directly on the storage.\n\
    =>1      : SpeeduPy will save the data loaded from the storage and the new data generated by the experiment in the same dictionary. It will be good during the execution of the experiment, but there may be an overhead for SpeeduPy to save the new data into storage.\n\
    =>2      : SpeeduPy will save the data loaded from the storage in one dictionary and the new data generated by the experiment in another dictionary. It will be good for saving new data into the storage, but there may be an overhead for SpeeduPy to search for data during the experiment execution\n\
    =>2-fast : SpeeduPy will save the data loaded from the storage and the new data generated by the experiment in the same dictionary, but there will be a second dictionary with the references to the new data generated by the experiment. This setup should produce a good performance, but it will consume more RAM space.\n"

def retrieval_strategies_msg():
    return "\nRetrieval strategy options:\n\
    =>lazy     : SpeeduPy will always request only the data required for the experiment execution.\n\
    =>function : SpeeduPy will request all the data of a function when the experiment needs a specific data of a function\n\
    =>eager    : SpeeduPy will request all data saved on the storage before the experiment starts to execute\n"

def retrieval_exec_modes_msg():
    return "\nRetrieval execution mode options:\n\
    =>sequential : SpeeduPy will always request data from the storage sequentially, blocking the experiment execution during this process.\n\
    =>thread     : SpeeduPy will request data from the storage using a thread. It will allow the experiment to execute while the data is being loaded to RAN\n"

def get_params():
    exec_modes = ['no-cache', 'manual', 'accurate', 'multiprocess', 'probabilistic']
    prob_mode_strategies = ['counting', 'error']
    revalidations = ['none', 'fixed', 'adaptative']
    retrieval_strategies = ['lazy', 'function', 'eager']
    retrieval_exec_modes = ['sequential', 'thread']
    num_dicts = ['0', '1', '2', '2-fast']
    hashes = ['md5', 'murmur', 'xxhash']
    storageOptions = ['db','file']

    speedupy_arg_parser = argparse.ArgumentParser(usage=help_msg())
    
    speedupy_arg_parser.add_argument('args',
                                   metavar='program arguments',
                                   nargs='*',
                                   type=str, 
                                   help='program arguments')
        
    speedupy_arg_parser.add_argument('--exec-mode',
                                  choices=exec_modes,
                                  metavar='',
                                  nargs=1,
                                  default=None,
                                  help='defines how SpeeduPy will execute')
    
    speedupy_arg_parser.add_argument('--strategy',
                                  choices=prob_mode_strategies,
                                  metavar='',
                                  default=None,
                                  nargs=1,
                                  help='defines SpeeduPy\'s policy for caching function calls when executing in probabilistic mode')
    
    speedupy_arg_parser.add_argument('--revalidation',
                                  choices=revalidations,
                                  metavar='',
                                  default=['adaptative'],
                                  nargs=1,
                                  help='defines if Speedupy should reexecute a function sometimes to validate that the function continues to be safe to cache. There are three possible variations for this algorithm, depending on the execution mode selected.')
    
    speedupy_arg_parser.add_argument('--max-num-exec-til-revalidation',
                                  default=10,
                                  metavar='',
                                  type=int,
                                  nargs=1,
                                  help='defines the maximum number of times a function can be cached before a revalidation occurs.')
    
    speedupy_arg_parser.add_argument('--reduction-factor',
                                  default=0.3,
                                  metavar='',
                                  type=float,
                                  nargs=1,
                                  help='defines the factor used to update the next number of cached functions before the next revalidation occurs.')

    speedupy_arg_parser.add_argument('--min-num-exec',
                                  default=20,
                                  metavar='',
                                  type=int,
                                  nargs=1,
                                  help='defines them minimum number of times SpeeduPy\'s must execute a function call before trying to cache it')
    
    speedupy_arg_parser.add_argument('--min-mode-occurrence',
                                  default=0.8,
                                  metavar='',
                                  nargs=1,
                                  help='used when "exec-mode=probabilistic strategy={counting, frequency}" is set. Defines the minimum frequency of appearances (in percentage) that the statistical mode must have for a function to be accelerated. The value informed must be between 0 and 1.')
    
    speedupy_arg_parser.add_argument('--confidence-level',
                                  default=0.95,
                                  metavar='',
                                  nargs=1,
                                  help='used when "exec-mode=probabilistic strategy=error" is set. Defines the confidence level used to estimate the margim of error and confidence interval of a function. The value informed must be between 0 and 1.')
    
    speedupy_arg_parser.add_argument('--max-error-per-function',
                                  default=None,
                                  metavar='',
                                  nargs=1,
                                  help='used when "exec-mode=probabilistic strategy=error" is set. Defines the maximum error the user considers acceptable for a function to introduce when it is cached. This error correspond to the margin of error of the confidence interval calculated. Notice, that an execution of a function can produce an output that is not inside the confidence interval, in which case the error produced by the function would be greater then the margin of error the confidence interval. The probability of this occurring is (1 - confidence_level).')
    
    speedupy_arg_parser.add_argument('--retrieval-strategy',
                                   choices=retrieval_strategies,
                                   metavar='',
                                   nargs=1,
                                   type=str,
                                   default=['eager'],
                                   help='Defines how SpeeduPy\'s should load cached data saved on the storage')
    
    speedupy_arg_parser.add_argument('--retrieval-exec-mode',
                                   choices=retrieval_exec_modes,
                                   metavar='',
                                   nargs=1,
                                   type=str,
                                   default=['sequential'],
                                   help='Defines how SpeeduPy\'s should load cached data saved on the storage')
    
    speedupy_arg_parser.add_argument('--num-dict',
                                   choices=num_dicts,
                                   metavar='',
                                   nargs=1,
                                   type=str,
                                   default=['2-fast'],
                                   help='Defines how SpeeduPy\'s should store the data on RAM during the experiment execution')

    speedupy_arg_parser.add_argument('-H',
                                  '--hash',
                                   choices=hashes,
                                   metavar='',
                                   nargs=1,
                                   default=['md5'],
                                   help='SpeeduPy\'s mechanism of hashes: choose one of the following options: '+', '.join(hashes))
    
    speedupy_arg_parser.add_argument('-s',
                                  '--storage',
                                   choices=storageOptions,
                                   metavar='',
                                   nargs=1,
                                   default=['db'],
                                   help='SpeeduPy\'s mechanism of storage: choose one of the following options: '+', '.join(storageOptions))
    
    args = speedupy_arg_parser.parse_args()
    
    argsp_num_dict = args.num_dict
    argsp_retrieval_strategy = args.retrieval_strategy
    argsp_retrieval_exec_mode = args.retrieval_exec_mode
    argsp_hash = args.hash
    argsp_s = args.storage

    argsp_exec_mode = args.exec_mode
    argsp_strategy = args.strategy
    argsp_revalidation = args.revalidation
    argsp_max_num_exec_til_revalidation = args.max_num_exec_til_revalidation
    argsp_reduction_factor = args.reduction_factor
    argsp_min_num_exec = args.min_num_exec
    argsp_min_mode_occurrence = args.min_mode_occurrence
    argsp_confidence_level = args.confidence_level
    argsp_max_error_per_function = args.max_error_per_function
    
    return argsp_num_dict, argsp_retrieval_strategy, argsp_retrieval_exec_mode, argsp_hash, argsp_s, argsp_exec_mode, argsp_strategy, argsp_revalidation, argsp_max_num_exec_til_revalidation, argsp_reduction_factor, argsp_min_num_exec, argsp_min_mode_occurrence, argsp_confidence_level, argsp_max_error_per_function
